{
  "slug": "working-with-ai-at-production-scale",
  "title": "Working with AI at Production Scale",
  "description": "People think AI is for the hobbyists, but learning to use AI at production scale is one of the fastest ways to sharpen your skills, as long as you stay intentional about context, tooling, and review.",
  "date": "2026-02-13T00:00:00.000Z",
  "coverImageUrl": "https://raw.githubusercontent.com/sbpete/blog/main/images/working-with-ai-at-production-scale-1770948964634-gemini_generated_image_mb6w59mb6w59mb6w.png",
  "tags": [
    "AI",
    "Software Engineering"
  ],
  "contentMarkdown": "Everyone says you should “learn AI by building side projects,” and that is a good start. But if you really want to level up fast, the best thing you can do is learn to use AI at **production** scale, inside real systems that real users depend on.\n\nToy scripts are forgiving. Production is not. Production forces you to care about reliability, observability, edge cases, and all the unglamorous details that actually make an AI workflow useful instead of just impressive in a demo.\n\n## Your AI Is Only as Smart as Its Context\n\nBefore you even think about letting an AI assistant touch your code, you need to set up its world.\n\nThat starts with workspace indexing. Your assistant should have access to:\n\n- High-quality documentation and READMEs  \n- Current best practices and coding standards  \n- Team workflows and deployment patterns  \n- Any quirks or historical decisions in the codebase  \n\nIf the AI cannot see how your system works, it will happily generate code that compiles but does not belong anywhere. Context is not optional; it is the foundation.\n\n## A Boring Workflow That Actually Works\n\nMost of the magic is in how you structure the work.\n\n- Break the task into small, concrete chunks.  \n- Provide clear context for each chunk.  \n- Define what “done” looks like with explicit validation criteria.  \n- Let the AI handle one step at a time.  \n- Review, test, and validate the result.  \n- Iterate.\n\nThis workflow is not glamorous, but it gives you two big benefits at once. First, it keeps the codebase from turning into AI-generated spaghetti. Second, you get constant repetitions in thinking at a production level instead of just pasting in giant prompts and hoping for the best.\n\n## Learn the Tool, Not Just the Vibes\n\nIf you want to get good with AI, you have to treat your assistant like a real tool, not a magic trick.\n\nGet familiar with:\n\n- The full command set and shortcuts  \n- How “agent” or “project” modes behave differently than simple chat  \n- Where it looks for context and how that scope is decided  \n- How many tokens different operations consume and how that affects cost and behavior  \n\nWhen you push these tools in real environments with real constraints, you are forced to notice their edge cases and failure modes. That pressure is exactly what sharpens your instincts in a way hobby projects never will.\n\n## When AI Learns From Your Worst Habits\n\nThere is a subtle failure mode most people underestimate: your AI learns from whatever you feed it.\n\nIf your codebase is already messy and needlessly complex, that becomes the AI’s reference point. It will mirror your technical debt back at you, creating a feedback loop that slowly makes everything worse. The more work you hand off without checking, the more tangled the system becomes.\n\nAnd then there is what happens to you.\n\nWhen you stop tracing through code and only check whether it “looks fine,” you stop exercising the part of your brain that actually understands systems. Over time, your ability to reason about architecture, debug deeply, and read unfamiliar code starts to dull. You are still “shipping,” but you are learning less with every commit.\n\n## The Bill Always Comes Due\n\nAt some point something will break, preferably not in production, but reality is not always kind. If you have treated AI as an unchecked code generator, you are now responsible for debugging a system you never really understood.\n\nWorking with AI at production scale is the opposite of that. You let the AI move faster on the mechanical parts, but you stay fully engaged:\n\n- You understand what it is generating.  \n- You trace how it fits into the rest of the system.  \n- You keep the architecture simpler than the model wants to make it.\n\nThat combination is where the real skill growth happens. Using AI in production does not just make you faster. Done right, it makes you sharper, more deliberate, and far more dangerous in the best way as a software engineer."
}